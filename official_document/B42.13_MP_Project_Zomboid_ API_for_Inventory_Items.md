Below is the **Markdown conversion** of **“Project Zomboid – API for Inventory Items (Document version 1.0)”**, with structure preserved and all code blocks normalized. Content is taken directly from the uploaded file .

---

# Project Zomboid

## API for Inventory Items

**Document version:** 1.0

---

## Contents

1. Introduction
2. General Description
3. Timed Action Architecture

   * 3.1 Modification of the `new` Function
   * 3.2 Realisation of the `getDuration` Function
   * 3.3 Split of the `perform` Function into `perform` and `complete`
4. Realisation Features of Long Timed Actions
5. The Use of `sendClientCommand`
6. Synchronisation of the Creation, Deletion, and Modification of Items and Objects

---

## Introduction

This document is intended for **Project Zomboid modders** and describes the new system for **Inventory Item manipulation**, developed to prevent cheating.

All Inventory Item processing in **multiplayer** is handled on the **server side**.

* Client-side creation of inventory items is still possible, but:

  * Such items **cannot be interacted with**
  * They will be **deleted after relogin**
* All items **must be created on the server**
* Items are then synchronised to the client

This ensures inventory consistency between client and server.

---

## 1. General Description

The primary method for Inventory Item creation, deletion, and modification is via **Timed Actions**.

* Item manipulation must occur on the **server**
* Client inventories are updated to mirror the server state

### Alternative Method

Inventory manipulation may also be performed using:

* `sendCommand`
* `sendClientCommand`

This requires:

* A custom command processor
* Cheating validation
* Server-side item creation/deletion/modification
* Manual synchronisation back to clients

This approach is suitable for **non-player-driven actions**, such as **admin powers**.

---

## 2. Timed Action Architecture

Timed Actions can now execute on **both client and server**.

To adapt an existing Timed Action:

1. Move the Lua file from:

   ```
   media/lua/client
   ```

   to:

   ```
   media/lua/shared
   ```
2. Ensure all constructor arguments match object field names
3. Implement `getDuration`
4. Split `perform` into:

   * `perform`
   * `complete`
5. Send synchronisation updates in `complete`

### Execution Rules

* **Client:** executes `perform`
* **Server:** executes `complete`
* **Singleplayer:** executes `perform` → `complete`

---

## 2.1 Modification of the `new` Function

When a Timed Action is sent to the server, the Lua object is reconstructed using the **arguments of `new`**.

### Incorrect Example

```lua
function ISPlaceTrap:new(playerObj, trap, damage, maxTime)
    local o = ISBaseTimedAction.new(self, playerObj);
    o.square = character:getCurrentSquare();
    o.weapon = trap;
    o.damage = damage / 20;
    o.maxTime = maxTime;
    return o;
end
```

**Problems:**

* Argument names do not match object fields
* Modified values are re-serialized incorrectly
* Execution time can be exploited by cheaters

---

### ISBaseTimedAction Constructor (Reference)

```lua
function ISBaseTimedAction:new(character)
    local o = {}
    setmetatable(o, self)
    self.__index = self
    o.character = character;
    o.stopOnWalk = true;
    o.stopOnRun = true;
    o.stopOnAim = true;
    o.caloriesModifier = 1;
    o.maxTime = -1;
    return o
end
```

---

### Correct Implementation

```lua
function ISPlaceTrap:new(character, weapon)
    local o = ISBaseTimedAction.new(self, character);
    o.square = character:getCurrentSquare();
    o.weapon = weapon;
    o.maxTime = o:getDuration();
    return o;
end
```

---

### Supported Argument Types for `new`

* BaseVehicle
* BloodBodyPartType
* BodyPart
* Boolean
* CraftRecipe
* Double
* EvolvedRecipe
* FluidContainer
* Integer
* InventoryItem
* IsoAnimal
* IsoDeadBody
* IsoGridSquare
* IsoHutch.NestBox
* IsoObject
* IsoPlayer
* ItemContainer
* KahluaTableImpl
* MultiStageBuilding.Stage
* PZNetKahluaTableImpl
* Recipe
* Resource
* SpriteConfigManager.ObjectInfo
* String
* VehiclePart
* VehicleWindow
* `null`

**Note:**
Objects created client-side **cannot** be passed as arguments.

---

## 2.2 Realisation of the `getDuration` Function

`getDuration` determines how long a Timed Action takes, in **cycles**.

* 1 second = `50` cycles
* Instant action = `1`
* Infinite action = `-1`
* If `TimedActionInstant` cheat is enabled → return `1`

### Example

```lua
function ISPlaceTrap:getDuration()
    if self.character:isTimedActionInstant() then
        return 1;
    end
    return 50
end
```

---

## 2.3 Split of `perform` and `complete`

### Rules

**perform**

* Client-side only
* Animation, sound, UI
* No item or object manipulation

**complete**

* Server-side only
* Inventory and object manipulation
* Must be server-safe

---

### Obsolete `perform` Example

```lua
function ISAddFuelAction:perform()
    self.character:stopOrTriggerSound(self.sound)
    self.item:setJobDelta(0.0);
    if self.item:IsDrainable() then
        self.item:Use()
    else
        self.character:removeFromHands(self.item)
        self.character:getInventory():Remove(self.item)
    end
    local cf = self.campfire
    local args = { x = cf.x, y = cf.y, z = cf.z, fuelAmt = self.fuelAmt }
    CCampfireSystem.instance:sendCommand(self.character, 'addFuel', args)
    ISBaseTimedAction.perform(self);
end
```

---

### Updated `perform`

```lua
function ISAddFuelAction:perform()
    self.character:stopOrTriggerSound(self.sound)
    self.item:setJobDelta(0.0);
    ISBaseTimedAction.perform(self);
end
```

---

### New `complete`

```lua
function ISAddFuelAction:complete()
    if self.item:IsDrainable() then
        self.item:UseAndSync()
    else
        self.character:removeFromHands(self.item)
        self.character:getInventory():Remove(self.item)
        sendRemoveItemFromContainer(self.character:getInventory(), self.item)
    end

    local campfire = SCampfireSystem.instance:getLuaObjectAt(
        self.campfire.x,
        self.campfire.y,
        self.campfire.z
    )

    if campfire then
        campfire:addFuel(self.fuelAmt)
    end

    return true
end
```

---

## 3. Long Timed Actions

Used for actions with **periodic execution**, such as:

* Chopping trees
* Pouring liquids
* Reading books

### Required Functions

* `serverStart`
* `animEvent`

### Example: `serverStart`

```lua
function ISChopTreeAction:serverStart()
    self.axe = self.character:getPrimaryHandItem()
    emulateAnimEvent(self.netAction, 1500, "ChopTree", nil)
end
```

---

### Example: `animEvent`

```lua
function ISChopTreeAction:animEvent(event, parameter)
    if not isClient() then
        if event == 'ChopTree' then
            self.tree:WeaponHit(self.character, self.axe)
            self:useEndurance()
            if self.tree:getObjectIndex() == -1 then
                if isServer() then
                    self.netAction:forceComplete()
                else
                    self:forceComplete()
                end
            end
        end
    else
        if event == 'ChopTree' then
            self.tree:WeaponHitEffects(self.character, self.axe)
        end
    end
end
```

---

## 4. The Use of `sendClientCommand`

Used to send commands from client to server.

### Signature

```lua
sendClientCommand(player, module, command, args)
```

### Example

```lua
sendClientCommand(self.player, "vehicle", "getKey", {
    vehicle = self.vehicle:getId()
})
```

---

### Server Handler Example

```lua
local VehicleCommands = {}
local Commands = {}

function Commands.getKey(player, args)
    local vehicle = getVehicleById(args.vehicle)
    if vehicle and checkPermissions(player, Capability.UseMechanicsCheat) then
        local item = vehicle:createVehicleKey()
        if item then
            player:getInventory():AddItem(item);
            sendAddItemToContainer(player:getInventory(), item);
        end
    end
end

VehicleCommands.OnClientCommand = function(module, command, player, args)
    if module == 'vehicle' and Commands[command] then
        Commands[command](player, args)
    end
end

Events.OnClientCommand.Add(VehicleCommands.OnClientCommand)
```

---

## 5. Synchronisation of Items and Objects

All changes made in `complete` **must be synchronised**.

### Inventory Functions

* `sendAddItemToContainer`
* `sendRemoveItemFromContainer`
* `syncItemFields`
* `syncItemModData`
* `syncHandWeaponFields`
* `sendItemStats`

### Object Functions

* `transmitCompleteItemToClients`
* `transmitRemoveItemFromSquare`
* `sync`
* `transmitUpdatedSpriteToClients`

---

### Examples

#### Add Inventory Item

```lua
local candle = instanceItem("Base.Candle")
self.character:getInventory():AddItem(candle);
sendAddItemToContainer(self.character:getInventory(), candle);
```

#### Remove Inventory Item

```lua
self.character:removeFromHands(self.weapon)
self.character:getInventory():Remove(self.weapon);
sendRemoveItemFromContainer(self.character:getInventory(), self.weapon);
```

#### Add IsoObject

```lua
local trap = IsoTrap.new(self.weapon, self.square:getCell(), self.square);
self.square:AddTileObject(trap);
trap:transmitCompleteItemToClients();
```

#### Remove IsoObject

```lua
self.trap:getSquare():transmitRemoveItemFromSquare(self.trap);
self.trap:removeFromWorld();
self.trap:removeFromSquare();
```

#### Sync IsoObject

```lua
self.generator:setActivated(self.activate)
self.generator:sync()
```

---
